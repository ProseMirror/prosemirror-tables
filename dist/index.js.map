{"version":3,"file":"index.js","names":["readFromCache: (key: Node) => TableMap | undefined","addToCache: (key: Node, value: TableMap) => TableMap","cache: (Node | TableMap)[]","width: number","height: number","map: number[]","problems: Problem[] | null","result: number[]","seen: Record<number, boolean>","colWidths: ColWidths","result: ColWidths","result: MutableAttrs","attrs: MutableAttrs","cellAttrs: Record<string, AttributeSpec>","result: CellAttrs","seen: Record<number, boolean>","anchor: number","head: number","cells: Decoration[]","fromCellBoundaryNode: Node | undefined","toCellBoundaryNode: Node | undefined","normalize: Selection | undefined","role: string | undefined","tr: Transaction | undefined","mustAdd: number[]","role: TableRole","nodes: Node[]","rows: (Node | null)[][]","colCount","row: (Node | null)[]","newRows: Node[]","oldRow: Node","newCells: Node[]","target: number","anchor: number","head: number","moveTableColumn","moveTableRow","refColumn: number | null","refRow: number | null","seen: Record<number, boolean>","mergedPos: number | undefined","mergedCell: Node | undefined","cellNode: Node | null | undefined","cellPos: number | undefined","toggleHeaderRow: Command","toggleHeaderColumn: Command","toggleHeaderCell: Command","widths: ColWidths","added: number[]","newRows: Fragment[]","cells: Node[]","add: Node","start","cellSel: CellSelection","handleMouseDown","$anchor","dirStr: 'up' | 'down' | 'left' | 'right'","node: Node","defaultCellMinWidth: number","col","activeHandle: number","dragging: Dragging | false","pluginState","event","dom: Node | null","handleMouseDown"],"sources":["../src/tablemap.ts","../src/schema.ts","../src/util.ts","../src/cellselection.ts","../src/fixtables.ts","../src/utils/convert.ts","../src/utils/move-row-in-array-of-rows.ts","../src/utils/query.ts","../src/utils/get-cells.ts","../src/utils/selection-range.ts","../src/utils/transpose.ts","../src/utils/move-column.ts","../src/utils/move-row.ts","../src/commands.ts","../src/copypaste.ts","../src/input.ts","../src/tableview.ts","../src/columnresizing.ts","../src/index.ts"],"sourcesContent":["// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\nimport type { Attrs, Node } from 'prosemirror-model';\n\nimport type { CellAttrs } from './util';\n\n/**\n * @public\n */\nexport type ColWidths = number[];\n\n/**\n * @public\n */\nexport type Problem =\n  | {\n      type: 'colwidth mismatch';\n      pos: number;\n      colwidth: ColWidths;\n    }\n  | {\n      type: 'collision';\n      pos: number;\n      row: number;\n      n: number;\n    }\n  | {\n      type: 'missing';\n      row: number;\n      n: number;\n    }\n  | {\n      type: 'overlong_rowspan';\n      pos: number;\n      n: number;\n    }\n  | {\n      type: 'zero_sized';\n    };\n\nlet readFromCache: (key: Node) => TableMap | undefined;\nlet addToCache: (key: Node, value: TableMap) => TableMap;\n\n// Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\nif (typeof WeakMap != 'undefined') {\n  let cache = new WeakMap<Node, TableMap>();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache: (Node | TableMap)[] = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1] as TableMap;\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return (cache[cachePos++] = value);\n  };\n}\n\n/**\n * @public\n */\nexport interface Rect {\n  left: number;\n  top: number;\n  right: number;\n  bottom: number;\n}\n\n/**\n * A table map describes the structure of a given table. To avoid\n * recomputing them all the time, they are cached per table node. To\n * be able to do that, positions saved in the map are relative to the\n * start of the table, rather than the start of the document.\n *\n * @public\n */\nexport class TableMap {\n  constructor(\n    /**\n     * The number of columns\n     */\n    public width: number,\n    /**\n     * The number of rows\n     */\n    public height: number,\n    /**\n     * A width * height array with the start position of\n     * the cell covering that part of the table in each slot\n     */\n    public map: number[],\n    /**\n     * An optional array of problems (cell overlap or non-rectangular\n     * shape) for the table, used by the table normalizer.\n     */\n    public problems: Problem[] | null,\n  ) {}\n\n  // Find the dimensions of the cell at the given position.\n  findCell(pos: number): Rect {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n\n      const left = i % this.width;\n      const top = (i / this.width) | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (\n        let j = 1;\n        bottom < this.height && this.map[i + this.width * j] == curPos;\n        j++\n      ) {\n        bottom++;\n      }\n\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n\n  // Find the left side of the cell at the given position.\n  colCount(pos: number): number {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos: number, axis: 'horiz' | 'vert', dir: number): null | number {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == 'horiz') {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a: number, b: number): Rect {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA,\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB,\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB),\n    };\n  }\n\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect: Rect): number[] {\n    const result: number[] = [];\n    const seen: Record<number, boolean> = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n\n        if (seen[pos]) continue;\n        seen[pos] = true;\n\n        if (\n          (col == rect.left && col && this.map[index - 1] == pos) ||\n          (row == rect.top && row && this.map[index - this.width] == pos)\n        ) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row: number, col: number, table: Node): number {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        // Skip past cells from previous rows (via rowspan)\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n\n  // Find the table map for the given table node.\n  static get(table: Node): TableMap {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n}\n\n// Compute a table map.\nfunction computeMap(table: Node): TableMap {\n  if (table.type.spec.tableRole != 'table')\n    throw new RangeError('Not a table node: ' + table.type.name);\n  const width = findWidth(table),\n    height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems: Problem[] | null = null;\n  const colWidths: ColWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: 'overlong_rowspan',\n            pos,\n            n: rowspan - h,\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: 'collision',\n              row,\n              pos,\n              n: colspan - w,\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = ((start + w) % width) * 2,\n              prev = colWidths[widthIndex];\n            if (\n              prev == null ||\n              (prev != colW && colWidths[widthIndex + 1] == 1)\n            ) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: 'missing', row, n: missing });\n    pos++;\n  }\n\n  if (width === 0 || height === 0)\n    (problems || (problems = [])).push({ type: 'zero_sized' });\n\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n\n  // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n\n  return tableMap;\n}\n\nfunction findWidth(table: Node): number {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\n\nfunction findBadColWidths(\n  map: TableMap,\n  colWidths: ColWidths,\n  table: Node,\n): void {\n  if (!map.problems) map.problems = [];\n  const seen: Record<number, boolean> = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n\n    let updated = null;\n    const attrs = node.attrs as CellAttrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (\n        colWidth != null &&\n        (!attrs.colwidth || attrs.colwidth[j] != colWidth)\n      )\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: 'colwidth mismatch',\n        pos,\n        colwidth: updated,\n      });\n  }\n}\n\nfunction freshColWidth(attrs: Attrs): ColWidths {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result: ColWidths = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n","// Helper for creating a schema that supports tables.\n\nimport type {\n  AttributeSpec,\n  Attrs,\n  Node,\n  NodeSpec,\n  NodeType,\n  Schema,\n} from 'prosemirror-model';\n\nimport type { CellAttrs, MutableAttrs } from './util';\n\nfunction getCellAttrs(dom: HTMLElement | string, extraAttrs: Attrs): Attrs {\n  if (typeof dom === 'string') {\n    return {};\n  }\n\n  const widthAttr = dom.getAttribute('data-colwidth');\n  const widths =\n    widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr)\n      ? widthAttr.split(',').map((s) => Number(s))\n      : null;\n  const colspan = Number(dom.getAttribute('colspan') || 1);\n  const result: MutableAttrs = {\n    colspan,\n    rowspan: Number(dom.getAttribute('rowspan') || 1),\n    colwidth: widths && widths.length == colspan ? widths : null,\n  } satisfies CellAttrs;\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\n\nfunction setCellAttrs(node: Node, extraAttrs: Attrs): Attrs {\n  const attrs: MutableAttrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs['data-colwidth'] = node.attrs.colwidth.join(',');\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\n\n/**\n * @public\n */\nexport type getFromDOM = (dom: HTMLElement) => unknown;\n\n/**\n * @public\n */\nexport type setDOMAttr = (value: unknown, attrs: MutableAttrs) => void;\n\n/**\n * @public\n */\nexport interface CellAttributes {\n  /**\n   * The attribute's default value.\n   */\n  default: unknown;\n\n  /**\n   * A function or type name used to validate values of this attribute.\n   *\n   * See [validate](https://prosemirror.net/docs/ref/#model.AttributeSpec.validate).\n   */\n  validate?: string | ((value: unknown) => void);\n\n  /**\n   * A function to read the attribute's value from a DOM node.\n   */\n  getFromDOM?: getFromDOM;\n\n  /**\n   * A function to add the attribute's value to an attribute\n   * object that's used to render the cell's DOM.\n   */\n  setDOMAttr?: setDOMAttr;\n}\n\n/**\n * @public\n */\nexport interface TableNodesOptions {\n  /**\n   * A group name (something like `\"block\"`) to add to the table\n   * node type.\n   */\n  tableGroup?: string;\n\n  /**\n   * The content expression for table cells.\n   */\n  cellContent: string;\n\n  /**\n   * Additional attributes to add to cells. Maps attribute names to\n   * objects with the following properties:\n   */\n  cellAttributes: { [key: string]: CellAttributes };\n}\n\n/**\n * @public\n */\nexport type TableNodes = Record<\n  'table' | 'table_row' | 'table_cell' | 'table_header',\n  NodeSpec\n>;\n\nfunction validateColwidth(value: unknown) {\n  if (value === null) {\n    return;\n  }\n  if (!Array.isArray(value)) {\n    throw new TypeError('colwidth must be null or an array');\n  }\n  for (const item of value) {\n    if (typeof item !== 'number') {\n      throw new TypeError('colwidth must be null or an array of numbers');\n    }\n  }\n}\n\n/**\n * This function creates a set of [node\n * specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n * `table`, `table_row`, and `table_cell` nodes types as used by this\n * module. The result can then be added to the set of nodes when\n * creating a schema.\n *\n * @public\n */\nexport function tableNodes(options: TableNodesOptions): TableNodes {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs: Record<string, AttributeSpec> = {\n    colspan: { default: 1, validate: 'number' },\n    rowspan: { default: 1, validate: 'number' },\n    colwidth: { default: null, validate: validateColwidth },\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = {\n      default: extraAttrs[prop].default,\n      validate: extraAttrs[prop].validate,\n    };\n\n  return {\n    table: {\n      content: 'table_row+',\n      tableRole: 'table',\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: 'table' }],\n      toDOM() {\n        return ['table', ['tbody', 0]];\n      },\n    },\n    table_row: {\n      content: '(table_cell | table_header)*',\n      tableRole: 'row',\n      parseDOM: [{ tag: 'tr' }],\n      toDOM() {\n        return ['tr', 0];\n      },\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'cell',\n      isolating: true,\n      parseDOM: [\n        { tag: 'td', getAttrs: (dom) => getCellAttrs(dom, extraAttrs) },\n      ],\n      toDOM(node) {\n        return ['td', setCellAttrs(node, extraAttrs), 0];\n      },\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'header_cell',\n      isolating: true,\n      parseDOM: [\n        { tag: 'th', getAttrs: (dom) => getCellAttrs(dom, extraAttrs) },\n      ],\n      toDOM(node) {\n        return ['th', setCellAttrs(node, extraAttrs), 0];\n      },\n    },\n  };\n}\n\n/**\n * @public\n */\nexport type TableRole = 'table' | 'row' | 'cell' | 'header_cell';\n\n/**\n * @public\n */\nexport function tableNodeTypes(schema: Schema): Record<TableRole, NodeType> {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name],\n        role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n","// Various helper function for working with tables\n\nimport type { Attrs, Node, ResolvedPos } from 'prosemirror-model';\nimport type { EditorState, NodeSelection } from 'prosemirror-state';\nimport { PluginKey } from 'prosemirror-state';\n\nimport type { CellSelection } from './cellselection';\nimport { tableNodeTypes } from './schema';\nimport type { Rect } from './tablemap';\nimport { TableMap } from './tablemap';\n\n/**\n * @public\n */\nexport type MutableAttrs = Record<string, unknown>;\n\n/**\n * @public\n */\nexport interface CellAttrs {\n  colspan: number;\n  rowspan: number;\n  colwidth: number[] | null;\n}\n\n/**\n * @public\n */\nexport const tableEditingKey = new PluginKey<number>('selectingCells');\n\n/**\n * @public\n */\nexport function cellAround($pos: ResolvedPos): ResolvedPos | null {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == 'row')\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\n\nexport function cellWrapping($pos: ResolvedPos): null | Node {\n  for (let d = $pos.depth; d > 0; d--) {\n    // Sometimes the cell can be in the same depth.\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === 'cell' || role === 'header_cell') return $pos.node(d);\n  }\n  return null;\n}\n\n/**\n * @public\n */\nexport function isInTable(state: EditorState): boolean {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == 'row') return true;\n  return false;\n}\n\n/**\n * @internal\n */\nexport function selectionCell(state: EditorState): ResolvedPos {\n  const sel = state.selection as CellSelection | NodeSelection;\n  if ('$anchorCell' in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos\n      ? sel.$anchorCell\n      : sel.$headCell;\n  } else if (\n    'node' in sel &&\n    sel.node &&\n    sel.node.type.spec.tableRole == 'cell'\n  ) {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\n\n/**\n * @public\n */\nexport function cellNear($pos: ResolvedPos): ResolvedPos | undefined {\n  for (\n    let after = $pos.nodeAfter, pos = $pos.pos;\n    after;\n    after = after.firstChild, pos++\n  ) {\n    const role = after.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos);\n  }\n  for (\n    let before = $pos.nodeBefore, pos = $pos.pos;\n    before;\n    before = before.lastChild, pos--\n  ) {\n    const role = before.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell')\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\n\n/**\n * @public\n */\nexport function pointsAtCell($pos: ResolvedPos): boolean {\n  return $pos.parent.type.spec.tableRole == 'row' && !!$pos.nodeAfter;\n}\n\n/**\n * @public\n */\nexport function moveCellForward($pos: ResolvedPos): ResolvedPos {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter!.nodeSize);\n}\n\n/**\n * @internal\n */\nexport function inSameTable($cellA: ResolvedPos, $cellB: ResolvedPos): boolean {\n  return (\n    $cellA.depth == $cellB.depth &&\n    $cellA.pos >= $cellB.start(-1) &&\n    $cellA.pos <= $cellB.end(-1)\n  );\n}\n\n/**\n * @public\n */\nexport function findCell($pos: ResolvedPos): Rect {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\n\n/**\n * @public\n */\nexport function colCount($pos: ResolvedPos): number {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\n\n/**\n * @public\n */\nexport function nextCell(\n  $pos: ResolvedPos,\n  axis: 'horiz' | 'vert',\n  dir: number,\n): ResolvedPos | null {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\n\n/**\n * @public\n */\nexport function removeColSpan(attrs: CellAttrs, pos: number, n = 1): CellAttrs {\n  const result: CellAttrs = { ...attrs, colspan: attrs.colspan - n };\n\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\n\n/**\n * @public\n */\nexport function addColSpan(attrs: CellAttrs, pos: number, n = 1): Attrs {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\n\n/**\n * @public\n */\nexport function columnIsHeader(\n  map: TableMap,\n  table: Node,\n  col: number,\n): boolean {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width])!.type != headerCell)\n      return false;\n  return true;\n}\n","// This file defines a ProseMirror selection subclass that models\n// table cell selections. The table plugin needs to be active to wire\n// in the user interaction part of table selections (so that you\n// actually get such selections when you select across cells).\n\nimport type { Node, ResolvedPos } from 'prosemirror-model';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport type { EditorState, Transaction } from 'prosemirror-state';\nimport {\n  NodeSelection,\n  Selection,\n  SelectionRange,\n  TextSelection,\n} from 'prosemirror-state';\nimport type { Mappable } from 'prosemirror-transform';\nimport type { DecorationSource } from 'prosemirror-view';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\n\nimport { TableMap } from './tablemap';\nimport type { CellAttrs } from './util';\nimport { inSameTable, pointsAtCell, removeColSpan } from './util';\n\n/**\n * @public\n */\nexport interface CellSelectionJSON {\n  type: string;\n  anchor: number;\n  head: number;\n}\n\n/**\n * A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n * subclass that represents a cell selection spanning part of a table.\n * With the plugin enabled, these will be created when the user\n * selects across cells, and will be drawn by giving selected cells a\n * `selectedCell` CSS class.\n *\n * @public\n */\nexport class CellSelection extends Selection {\n  // A resolved position pointing _in front of_ the anchor cell (the one\n  // that doesn't move when extending the selection).\n  public $anchorCell: ResolvedPos;\n\n  // A resolved position pointing in front of the head cell (the one\n  // moves when extending the selection).\n  public $headCell: ResolvedPos;\n\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell: ResolvedPos, $headCell: ResolvedPos = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart,\n    );\n\n    const doc = $anchorCell.node(0);\n    const cells = map\n      .cellsInRect(rect)\n      .filter((p) => p != $headCell.pos - tableStart);\n    // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw new RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size),\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n\n  public map(doc: Node, mapping: Mappable): CellSelection | Selection {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (\n      pointsAtCell($anchorCell) &&\n      pointsAtCell($headCell) &&\n      inSameTable($anchorCell, $headCell)\n    ) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell);\n      else return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  public override content(): Slice {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart,\n    );\n    const seen: Record<number, boolean> = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (\n        let index = row * map.width + rect.left, col = rect.left;\n        col < rect.right;\n        col++, index++\n      ) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw new RangeError(`No cell with offset ${pos} found`);\n        }\n\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs as CellAttrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight,\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw new RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`,\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan:\n              Math.min(cellRect.bottom, rect.bottom) -\n              Math.max(cellRect.top, rect.top),\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs)!;\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n\n    const fragment =\n      this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n\n  public override replace(tr: Transaction, content: Slice = Slice.empty): void {\n    const mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content,\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1,\n    );\n    if (sel) tr.setSelection(sel);\n  }\n\n  public override replaceWith(tr: Transaction, node: Node): void {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n\n  public forEachCell(f: (node: Node, pos: number) => void): void {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart,\n      ),\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i])!, tableStart + cells[i]);\n    }\n  }\n\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  public isColSelection(): boolean {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter!.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter!.attrs.rowspan;\n\n    return (\n      Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount\n    );\n  }\n\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  public static colSelection(\n    $anchorCell: ResolvedPos,\n    $headCell: ResolvedPos = $anchorCell,\n  ): CellSelection {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart +\n            map.map[map.width * (map.height - 1) + headRect.right - 1],\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart +\n            map.map[map.width * (map.height - 1) + anchorRect.right - 1],\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  public isRowSelection(): boolean {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter!.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter!.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n\n  public eq(other: unknown): boolean {\n    return (\n      other instanceof CellSelection &&\n      other.$anchorCell.pos == this.$anchorCell.pos &&\n      other.$headCell.pos == this.$headCell.pos\n    );\n  }\n\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  public static rowSelection(\n    $anchorCell: ResolvedPos,\n    $headCell: ResolvedPos = $anchorCell,\n  ): CellSelection {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width],\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1],\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1],\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  public toJSON(): CellSelectionJSON {\n    return {\n      type: 'cell',\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos,\n    };\n  }\n\n  public static override fromJSON(\n    doc: Node,\n    json: CellSelectionJSON,\n  ): CellSelection {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n\n  static create(\n    doc: Node,\n    anchorCell: number,\n    headCell: number = anchorCell,\n  ): CellSelection {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n\n  public override getBookmark(): CellBookmark {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n}\n\nCellSelection.prototype.visible = false;\n\nSelection.jsonID('cell', CellSelection);\n\n/**\n * @public\n */\nexport class CellBookmark {\n  constructor(\n    public anchor: number,\n    public head: number,\n  ) {}\n\n  map(mapping: Mappable): CellBookmark {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n\n  resolve(doc: Node): CellSelection | Selection {\n    const $anchorCell = doc.resolve(this.anchor),\n      $headCell = doc.resolve(this.head);\n    if (\n      $anchorCell.parent.type.spec.tableRole == 'row' &&\n      $headCell.parent.type.spec.tableRole == 'row' &&\n      $anchorCell.index() < $anchorCell.parent.childCount &&\n      $headCell.index() < $headCell.parent.childCount &&\n      inSameTable($anchorCell, $headCell)\n    )\n      return new CellSelection($anchorCell, $headCell);\n    else return Selection.near($headCell, 1);\n  }\n}\n\nexport function drawCellSelection(state: EditorState): DecorationSource | null {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells: Decoration[] = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: 'selectedCell' }),\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\n\nfunction isCellBoundarySelection({ $from, $to }: TextSelection) {\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false; // Cheap elimination\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return (\n    afterFrom == beforeTo &&\n    /row|table/.test($from.node(depth).type.spec.tableRole)\n  );\n}\n\nfunction isTextSelectionAcrossCells({ $from, $to }: TextSelection) {\n  let fromCellBoundaryNode: Node | undefined;\n  let toCellBoundaryNode: Node | undefined;\n\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (\n      node.type.spec.tableRole === 'cell' ||\n      node.type.spec.tableRole === 'header_cell'\n    ) {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (\n      node.type.spec.tableRole === 'cell' ||\n      node.type.spec.tableRole === 'header_cell'\n    ) {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\n\nexport function normalizeSelection(\n  state: EditorState,\n  tr: Transaction | undefined,\n  allowTableNodeSelection: boolean,\n): Transaction | undefined {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize: Selection | undefined;\n  let role: string | undefined;\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == 'cell' || role == 'header_cell') {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == 'row') {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n","// This file defines helpers for normalizing tables, making sure no\n// cells overlap (which can happen, if you have the wrong col- and\n// rowspans) and that each row has the same width. Uses the problems\n// reported by `TableMap`.\n\nimport type { Node } from 'prosemirror-model';\nimport type { EditorState, Transaction } from 'prosemirror-state';\nimport { PluginKey } from 'prosemirror-state';\n\nimport type { TableRole } from './schema';\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './tablemap';\nimport type { CellAttrs } from './util';\nimport { removeColSpan } from './util';\n\n/**\n * @public\n */\nexport const fixTablesKey = new PluginKey<{ fixTables: boolean }>('fix-tables');\n\n/**\n * Helper for iterating through the nodes in a document that changed\n * compared to the given previous document. Useful for avoiding\n * duplicate work on each transaction.\n *\n * @public\n */\nfunction changedDescendants(\n  old: Node,\n  cur: Node,\n  offset: number,\n  f: (node: Node, pos: number) => void,\n): void {\n  const oldSize = old.childCount,\n    curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\n\n/**\n * Inspect all tables in the given state's document and return a\n * transaction that fixes them, if necessary. If `oldState` was\n * provided, that is assumed to hold a previous, known-good state,\n * which will be used to avoid re-scanning unchanged parts of the\n * document.\n *\n * @public\n */\nexport function fixTables(\n  state: EditorState,\n  oldState?: EditorState,\n): Transaction | undefined {\n  let tr: Transaction | undefined;\n  const check = (node: Node, pos: number) => {\n    if (node.type.spec.tableRole == 'table')\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\n\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nexport function fixTable(\n  state: EditorState,\n  table: Node,\n  tablePos: number,\n  tr: Transaction | undefined,\n): Transaction | undefined {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n\n  // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n  const mustAdd: number[] = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == 'collision') {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs as CellAttrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n),\n      );\n    } else if (prob.type == 'missing') {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == 'overlong_rowspan') {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n,\n      });\n    } else if (prob.type == 'colwidth mismatch') {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth,\n      });\n    } else if (prob.type == 'zero_sized') {\n      const pos = tr.mapping.map(tablePos);\n      tr.delete(pos, pos + table.nodeSize);\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role: TableRole = 'cell';\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes: Node[] = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n","import type { Node } from 'prosemirror-model';\n\nimport { TableMap } from '../tablemap';\n\n/**\n * This function will transform the table node into a matrix of rows and columns\n * respecting merged cells, for example this table:\n *\n * ```\n * ┌──────┬──────┬─────────────┐\n * │  A1  │  B1  │     C1      │\n * ├──────┼──────┴──────┬──────┤\n * │  A2  │     B2      │      │\n * ├──────┼─────────────┤  D1  │\n * │  A3  │  B3  │  C3  │      │\n * └──────┴──────┴──────┴──────┘\n * ```\n *\n * will be converted to the below:\n *\n * ```javascript\n * [\n *   [A1, B1, C1, null],\n *   [A2, B2, null, D1],\n *   [A3, B3, C3, null],\n * ]\n * ```\n * @internal\n */\nexport function convertTableNodeToArrayOfRows(\n  tableNode: Node,\n): (Node | null)[][] {\n  const map = TableMap.get(tableNode);\n  const rows: (Node | null)[][] = [];\n  const rowCount = map.height;\n  const colCount = map.width;\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row: (Node | null)[] = [];\n    for (let colIndex = 0; colIndex < colCount; colIndex++) {\n      const cellIndex = rowIndex * colCount + colIndex;\n      const cellPos = map.map[cellIndex];\n      if (rowIndex > 0) {\n        const topCellIndex = cellIndex - colCount;\n        const topCellPos = map.map[topCellIndex];\n        if (cellPos === topCellPos) {\n          row.push(null);\n          continue;\n        }\n      }\n      if (colIndex > 0) {\n        const leftCellIndex = cellIndex - 1;\n        const leftCellPos = map.map[leftCellIndex];\n        if (cellPos === leftCellPos) {\n          row.push(null);\n          continue;\n        }\n      }\n      row.push(tableNode.nodeAt(cellPos));\n    }\n    rows.push(row);\n  }\n\n  return rows;\n}\n\n/**\n * Convert an array of rows to a table node.\n *\n * @internal\n */\nexport function convertArrayOfRowsToTableNode(\n  tableNode: Node,\n  arrayOfNodes: (Node | null)[][],\n): Node {\n  const newRows: Node[] = [];\n  const map = TableMap.get(tableNode);\n  const rowCount = map.height;\n  const colCount = map.width;\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const oldRow: Node = tableNode.child(rowIndex);\n    const newCells: Node[] = [];\n\n    for (let colIndex = 0; colIndex < colCount; colIndex++) {\n      const cell = arrayOfNodes[rowIndex][colIndex];\n      if (!cell) {\n        continue;\n      }\n\n      const cellPos = map.map[rowIndex * map.width + colIndex];\n      const oldCell = tableNode.nodeAt(cellPos);\n      if (!oldCell) {\n        continue;\n      }\n\n      const newCell = oldCell.type.createChecked(\n        cell.attrs,\n        cell.content,\n        cell.marks,\n      );\n      newCells.push(newCell);\n    }\n\n    const newRow = oldRow.type.createChecked(\n      oldRow.attrs,\n      newCells,\n      oldRow.marks,\n    );\n    newRows.push(newRow);\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    newRows,\n    tableNode.marks,\n  );\n  return newTable;\n}\n","/**\n * Move a row in an array of rows.\n *\n * @internal\n */\nexport function moveRowInArrayOfRows<T>(\n  rows: T[],\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  directionOverride: -1 | 1 | 0,\n): T[] {\n  const direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;\n\n  const rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;\n  let target: number;\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0] - 1;\n  } else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;\n  } else {\n    target =\n      direction === -1\n        ? indexesTarget[0]\n        : indexesTarget[indexesTarget.length - 1] - positionOffset;\n  }\n\n  rows.splice(target, 0, ...rowsExtracted);\n  return rows;\n}\n","import type { Node, ResolvedPos } from 'prosemirror-model';\nimport type { Selection } from 'prosemirror-state';\n\nimport { CellSelection } from '../cellselection';\nimport { cellAround, cellNear, inSameTable } from '../util';\n\n/**\n * Checks if the given object is a `CellSelection` instance.\n *\n * @internal\n */\nfunction isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection;\n}\n\n/**\n * Find the closest table node for a given position.\n *\n * @public\n */\nexport function findTable($pos: ResolvedPos): FindNodeResult | null {\n  return findParentNode((node) => node.type.spec.tableRole === 'table', $pos);\n}\n\n/**\n * Try to find the anchor and head cell in the same table by using the given\n * anchor and head as hit points, or fallback to the selection's anchor and\n * head.\n *\n * @public\n */\nexport function findCellRange(\n  selection: Selection,\n  anchorHit?: number,\n  headHit?: number,\n): [ResolvedPos, ResolvedPos] | null {\n  if (anchorHit == null && headHit == null && isCellSelection(selection)) {\n    return [selection.$anchorCell, selection.$headCell];\n  }\n\n  const anchor: number = anchorHit ?? headHit ?? selection.anchor;\n  const head: number = headHit ?? anchorHit ?? selection.head;\n\n  const doc = selection.$head.doc;\n\n  const $anchorCell = findCellPos(doc, anchor);\n  const $headCell = findCellPos(doc, head);\n\n  if ($anchorCell && $headCell && inSameTable($anchorCell, $headCell)) {\n    return [$anchorCell, $headCell];\n  }\n  return null;\n}\n\n/**\n * Try to find a resolved pos of a cell by using the given pos as a hit point.\n *\n * @public\n */\nexport function findCellPos(doc: Node, pos: number): ResolvedPos | undefined {\n  const $pos = doc.resolve(pos);\n  return cellAround($pos) || cellNear($pos);\n}\n\n/**\n * Result of finding a parent node.\n *\n * @public\n */\nexport interface FindNodeResult {\n  /**\n   * The closest parent node that satisfies the predicate.\n   */\n  node: Node;\n\n  /**\n   * The position directly before the node.\n   */\n  pos: number;\n\n  /**\n   * The position at the start of the node.\n   */\n  start: number;\n\n  /**\n   * The depth of the node.\n   */\n  depth: number;\n}\n\n/**\n * Find the closest parent node that satisfies the predicate.\n *\n * @internal\n */\nfunction findParentNode(\n  /**\n   * The predicate to test the parent node.\n   */\n  predicate: (node: Node) => boolean,\n  /**\n   * The position to start searching from.\n   */\n  $pos: ResolvedPos,\n): FindNodeResult | null {\n  for (let depth = $pos.depth; depth >= 0; depth -= 1) {\n    const node = $pos.node(depth);\n\n    if (predicate(node)) {\n      const pos = depth === 0 ? 0 : $pos.before(depth);\n      const start = $pos.start(depth);\n      return { node, pos, start, depth };\n    }\n  }\n\n  return null;\n}\n","import type { Selection } from 'prosemirror-state';\n\nimport { TableMap } from '../tablemap';\n\nimport type { FindNodeResult } from './query';\nimport { findTable } from './query';\n\n/**\n * Returns an array of cells in a column at the specified column index.\n *\n * @internal\n */\nexport function getCellsInColumn(\n  columnIndex: number,\n  selection: Selection,\n): FindNodeResult[] | undefined {\n  const table = findTable(selection.$from);\n  if (!table) {\n    return;\n  }\n\n  const map = TableMap.get(table.node);\n\n  if (columnIndex < 0 || columnIndex > map.width - 1) {\n    return;\n  }\n\n  const cells = map.cellsInRect({\n    left: columnIndex,\n    right: columnIndex + 1,\n    top: 0,\n    bottom: map.height,\n  });\n\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)!;\n    const pos = nodePos + table.start;\n    return { pos, start: pos + 1, node, depth: table.depth + 2 };\n  });\n}\n\n/**\n * Returns an array of cells in a row at the specified row index.\n *\n * @internal\n */\nexport function getCellsInRow(\n  rowIndex: number,\n  selection: Selection,\n): FindNodeResult[] | undefined {\n  const table = findTable(selection.$from);\n  if (!table) {\n    return;\n  }\n\n  const map = TableMap.get(table.node);\n\n  if (rowIndex < 0 || rowIndex > map.height - 1) {\n    return;\n  }\n\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: rowIndex,\n    bottom: rowIndex + 1,\n  });\n\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)!;\n    const pos = nodePos + table.start;\n    return { pos, start: pos + 1, node, depth: table.depth + 2 };\n  });\n}\n","import type { ResolvedPos } from 'prosemirror-model';\nimport type { Transaction } from 'prosemirror-state';\n\nimport { getCellsInColumn, getCellsInRow } from './get-cells';\n\nexport type CellSelectionRange = {\n  $anchor: ResolvedPos;\n  $head: ResolvedPos;\n  // an array of column/row indexes\n  indexes: number[];\n};\n\n/**\n * Returns a range of rectangular selection spanning all merged cells around a\n * column at index `columnIndex`.\n *\n * Original implementation from Atlassian (Apache License 2.0)\n *\n * https://bitbucket.org/atlassian/atlassian-frontend-mirror/src/5f91cb871e8248bc3bae5ddc30bb9fd9200fadbb/editor/editor-tables/src/utils/get-selection-range-in-column.ts#editor/editor-tables/src/utils/get-selection-range-in-column.ts\n *\n * @internal\n */\nexport function getSelectionRangeInColumn(\n  tr: Transaction,\n  startColIndex: number,\n  endColIndex: number = startColIndex,\n): CellSelectionRange | undefined {\n  let startIndex = startColIndex;\n  let endIndex = endColIndex;\n\n  // looking for selection start column (startIndex)\n  for (let i = startColIndex; i >= 0; i--) {\n    const cells = getCellsInColumn(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = startColIndex; i <= endIndex; i++) {\n    const cells = getCellsInColumn(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInColumn(i, tr.selection);\n    if (maybeCells && maybeCells.length > 0) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n\n  const firstSelectedColumnCells = getCellsInColumn(startIndex, tr.selection);\n  const firstRowCells = getCellsInRow(0, tr.selection);\n  if (!firstSelectedColumnCells || !firstRowCells) {\n    return;\n  }\n\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos,\n  );\n\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInColumn(i, tr.selection);\n    if (columnCells && columnCells.length > 0) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j].pos === columnCells[0].pos) {\n          headCell = columnCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n  if (!headCell) {\n    return;\n  }\n\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n}\n\n/**\n * Returns a range of rectangular selection spanning all merged cells around a\n * row at index `rowIndex`.\n *\n * Original implementation from Atlassian (Apache License 2.0)\n *\n * https://bitbucket.org/atlassian/atlassian-frontend-mirror/src/5f91cb871e8248bc3bae5ddc30bb9fd9200fadbb/editor/editor-tables/src/utils/get-selection-range-in-row.ts#editor/editor-tables/src/utils/get-selection-range-in-row.ts\n *\n * @internal\n */\nexport function getSelectionRangeInRow(\n  tr: Transaction,\n  startRowIndex: number,\n  endRowIndex: number = startRowIndex,\n): CellSelectionRange | undefined {\n  let startIndex = startRowIndex;\n  let endIndex = endRowIndex;\n\n  // looking for selection start row (startIndex)\n  for (let i = startRowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  // looking for selection end row (endIndex)\n  for (let i = startRowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n        if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection);\n    if (maybeCells && maybeCells.length > 0) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection);\n  const firstColumnCells = getCellsInColumn(0, tr.selection);\n  if (!firstSelectedRowCells || !firstColumnCells) {\n    return;\n  }\n\n  const $anchor = tr.doc.resolve(\n    firstSelectedRowCells[firstSelectedRowCells.length - 1].pos,\n  );\n\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection);\n    if (rowCells && rowCells.length > 0) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j].pos === rowCells[0].pos) {\n          headCell = rowCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n  if (!headCell) {\n    return;\n  }\n\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n}\n","/**\n * Transposes a 2D array by flipping columns to rows.\n *\n * Transposition is a familiar algebra concept where the matrix is flipped\n * along its diagonal. For more details, see:\n * https://en.wikipedia.org/wiki/Transpose\n *\n * @example\n * ```javascript\n * const arr = [\n *   ['a1', 'a2', 'a3'],\n *   ['b1', 'b2', 'b3'],\n *   ['c1', 'c2', 'c3'],\n *   ['d1', 'd2', 'd3'],\n * ];\n *\n * const result = transpose(arr);\n * result === [\n *   ['a1', 'b1', 'c1', 'd1'],\n *   ['a2', 'b2', 'c2', 'd2'],\n *   ['a3', 'b3', 'c3', 'd3'],\n * ]\n * ```\n */\nexport function transpose<T>(array: T[][]): T[][] {\n  return array[0].map((_, i) => {\n    return array.map((column) => column[i]);\n  });\n}\n","import type { Node } from 'prosemirror-model';\nimport type { Transaction } from 'prosemirror-state';\n\nimport { CellSelection } from '../cellselection';\nimport { TableMap } from '../tablemap';\n\nimport {\n  convertArrayOfRowsToTableNode,\n  convertTableNodeToArrayOfRows,\n} from './convert';\nimport { moveRowInArrayOfRows } from './move-row-in-array-of-rows';\nimport { findTable } from './query';\nimport { getSelectionRangeInColumn } from './selection-range';\nimport { transpose } from './transpose';\n\n/**\n * Parameters for moving a column in a table.\n *\n * @internal\n */\nexport interface MoveColumnParams {\n  tr: Transaction;\n  originIndex: number;\n  targetIndex: number;\n  select: boolean;\n  pos: number;\n}\n\n/**\n * Move a column from index `origin` to index `target`.\n *\n * @internal\n */\nexport function moveColumn(moveColParams: MoveColumnParams): boolean {\n  const { tr, originIndex, targetIndex, select, pos } = moveColParams;\n  const $pos = tr.doc.resolve(pos);\n  const table = findTable($pos);\n  if (!table) return false;\n\n  const indexesOriginColumn = getSelectionRangeInColumn(\n    tr,\n    originIndex,\n  )?.indexes;\n  const indexesTargetColumn = getSelectionRangeInColumn(\n    tr,\n    targetIndex,\n  )?.indexes;\n\n  if (!indexesOriginColumn || !indexesTargetColumn) return false;\n\n  if (indexesOriginColumn.includes(targetIndex)) return false;\n\n  const newTable = moveTableColumn(\n    table.node,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0,\n  );\n\n  tr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n\n  if (!select) return true;\n\n  const map = TableMap.get(newTable);\n  const start = table.start;\n  const index = targetIndex;\n  const lastCell = map.positionAt(map.height - 1, index, newTable);\n  const $lastCell = tr.doc.resolve(start + lastCell);\n\n  const firstCell = map.positionAt(0, index, newTable);\n  const $firstCell = tr.doc.resolve(start + firstCell);\n\n  tr.setSelection(CellSelection.colSelection($lastCell, $firstCell));\n  return true;\n}\n\nfunction moveTableColumn(\n  table: Node,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0,\n) {\n  let rows = transpose(convertTableNodeToArrayOfRows(table));\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n  rows = transpose(rows);\n\n  return convertArrayOfRowsToTableNode(table, rows);\n}\n","import type { Node } from 'prosemirror-model';\nimport type { Transaction } from 'prosemirror-state';\n\nimport { CellSelection } from '../cellselection';\nimport { TableMap } from '../tablemap';\n\nimport {\n  convertArrayOfRowsToTableNode,\n  convertTableNodeToArrayOfRows,\n} from './convert';\nimport { moveRowInArrayOfRows } from './move-row-in-array-of-rows';\nimport { findTable } from './query';\nimport { getSelectionRangeInRow } from './selection-range';\n\n/**\n * Parameters for moving a row in a table.\n *\n * @internal\n */\nexport interface MoveRowParams {\n  tr: Transaction;\n  originIndex: number;\n  targetIndex: number;\n  select: boolean;\n  pos: number;\n}\n\n/**\n * Move a row from index `origin` to index `target`.\n *\n * @internal\n */\nexport function moveRow(moveRowParams: MoveRowParams): boolean {\n  const { tr, originIndex, targetIndex, select, pos } = moveRowParams;\n  const $pos = tr.doc.resolve(pos);\n  const table = findTable($pos);\n  if (!table) return false;\n\n  const indexesOriginRow = getSelectionRangeInRow(tr, originIndex)?.indexes;\n  const indexesTargetRow = getSelectionRangeInRow(tr, targetIndex)?.indexes;\n\n  if (!indexesOriginRow || !indexesTargetRow) return false;\n\n  if (indexesOriginRow.includes(targetIndex)) return false;\n\n  const newTable = moveTableRow(\n    table.node,\n    indexesOriginRow,\n    indexesTargetRow,\n    0,\n  );\n\n  tr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n\n  if (!select) return true;\n\n  const map = TableMap.get(newTable);\n  const start = table.start;\n  const index = targetIndex;\n  const lastCell = map.positionAt(index, map.width - 1, newTable);\n  const $lastCell = tr.doc.resolve(start + lastCell);\n\n  const firstCell = map.positionAt(index, 0, newTable);\n  const $firstCell = tr.doc.resolve(start + firstCell);\n\n  tr.setSelection(CellSelection.rowSelection($lastCell, $firstCell));\n  return true;\n}\n\nfunction moveTableRow(\n  table: Node,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0,\n) {\n  let rows = convertTableNodeToArrayOfRows(table);\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n\n  return convertArrayOfRowsToTableNode(table, rows);\n}\n","// This file defines a number of table-related commands.\n\nimport type { Node, NodeType, ResolvedPos } from 'prosemirror-model';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport type { Command, EditorState, Transaction } from 'prosemirror-state';\nimport { TextSelection } from 'prosemirror-state';\n\nimport { CellSelection } from './cellselection';\nimport type { Direction } from './input';\nimport type { TableRole } from './schema';\nimport { tableNodeTypes } from './schema';\nimport type { Rect } from './tablemap';\nimport { TableMap } from './tablemap';\nimport type { CellAttrs } from './util';\nimport {\n  addColSpan,\n  cellAround,\n  cellWrapping,\n  columnIsHeader,\n  isInTable,\n  moveCellForward,\n  removeColSpan,\n  selectionCell,\n} from './util';\nimport { moveColumn } from './utils/move-column';\nimport { moveRow } from './utils/move-row';\n\n/**\n * @public\n */\nexport type TableRect = Rect & {\n  tableStart: number;\n  map: TableMap;\n  table: Node;\n};\n\n/**\n * Helper to get the selected rectangle in a table, if any. Adds table\n * map, table node, and table start offset to the object for\n * convenience.\n *\n * @public\n */\nexport function selectedRect(state: EditorState): TableRect {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect =\n    sel instanceof CellSelection\n      ? map.rectBetween(\n          sel.$anchorCell.pos - tableStart,\n          sel.$headCell.pos - tableStart,\n        )\n      : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\n\n/**\n * Add a column at the given position in a table.\n *\n * @public\n */\nexport function addColumn(\n  tr: Transaction,\n  { map, tableStart, table }: TableRect,\n  col: number,\n): Transaction {\n  let refColumn: number | null = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    // If this position falls inside a col-spanning cell\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos)!;\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs as CellAttrs, col - map.colCount(pos)),\n      );\n      // Skip ahead if rowspan > 1\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type =\n        refColumn == null\n          ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refColumn])!.type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill()!);\n    }\n  }\n  return tr;\n}\n\n/**\n * Command to add a column before the column with the selection.\n *\n * @public\n */\nexport function addColumnBefore(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\n\n/**\n * Command to add a column after the column with the selection.\n *\n * @public\n */\nexport function addColumnAfter(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\n\n/**\n * @public\n */\nexport function removeColumn(\n  tr: Transaction,\n  { map, table, tableStart }: TableRect,\n  col: number,\n) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos)!;\n    const attrs = cell.attrs as CellAttrs;\n    // If this is part of a col-spanning cell\n    if (\n      (col > 0 && map.map[index - 1] == pos) ||\n      (col < map.width - 1 && map.map[index + 1] == pos)\n    ) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos)),\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\n\n/**\n * Command function that removes the selected columns from a table.\n *\n * @public\n */\nexport function deleteColumn(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart\n        ? tr.doc.nodeAt(rect.tableStart - 1)\n        : tr.doc;\n      if (!table) {\n        throw new RangeError('No table found');\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\n\n/**\n * @public\n */\nexport function rowIsHeader(map: TableMap, table: Node, row: number): boolean {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (table.nodeAt(map.map[col + row * map.width])?.type != headerCell)\n      return false;\n  return true;\n}\n\n/**\n * @public\n */\nexport function addRow(\n  tr: Transaction,\n  { map, tableStart, table }: TableRect,\n  row: number,\n): Transaction {\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow: number | null = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (\n      row > 0 &&\n      row < map.height &&\n      map.map[index] == map.map[index - map.width]\n    ) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos)!.attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1,\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type =\n        refRow == null\n          ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refRow * map.width])?.type;\n      const node = type?.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\n\n/**\n * Add a table row before the selection.\n *\n * @public\n */\nexport function addRowBefore(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\n\n/**\n * Add a table row after the selection.\n *\n * @public\n */\nexport function addRowAfter(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\n\n/**\n * @public\n */\nexport function removeRow(\n  tr: Transaction,\n  { map, table, tableStart }: TableRect,\n  row: number,\n): void {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  const seen = new Set<number>();\n\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n\n    // Skip cells that are checked already\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      const attrs = table.nodeAt(pos)!.attrs as CellAttrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1,\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      const cell = table.nodeAt(pos)!;\n      const attrs = cell.attrs as CellAttrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content,\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\n\n/**\n * Remove the selected rows from a table.\n *\n * @public\n */\nexport function deleteRow(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart\n        ? tr.doc.nodeAt(rect.tableStart - 1)\n        : tr.doc;\n      if (!table) {\n        throw new RangeError('No table found');\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\n\nfunction isEmpty(cell: Node): boolean {\n  const c = cell.content;\n\n  return (\n    c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0\n  );\n}\n\nfunction cellsOverlapRectangle({ width, height, map }: TableMap, rect: Rect) {\n  let indexTop = rect.top * width + rect.left,\n    indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n    indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (\n      (rect.left > 0 && map[indexLeft] == map[indexLeft - 1]) ||\n      (rect.right < width && map[indexRight] == map[indexRight + 1])\n    )\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (\n      (rect.top > 0 && map[indexTop] == map[indexTop - width]) ||\n      (rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n    )\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\n\n/**\n * Merge the selected cells into a single cell. Only available when\n * the selected cells' outline forms a rectangle.\n *\n * @public\n */\nexport function mergeCells(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  const sel = state.selection;\n  if (\n    !(sel instanceof CellSelection) ||\n    sel.$anchorCell.pos == sel.$headCell.pos\n  )\n    return false;\n  const rect = selectedRect(state),\n    { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen: Record<number, boolean> = {};\n    let content = Fragment.empty;\n    let mergedPos: number | undefined;\n    let mergedCell: Node | undefined;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs as CellAttrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan,\n      ),\n      rowspan: rect.bottom - rect.top,\n    });\n    if (content.size > 0) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)),\n    );\n    dispatch(tr);\n  }\n  return true;\n}\n\n/**\n * Split a selected cell, whose rowpan or colspan is greater than one,\n * into smaller cells. Use the first cell type for the new cells.\n *\n * @public\n */\nexport function splitCell(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole as TableRole];\n  })(state, dispatch);\n}\n\n/**\n * @public\n */\nexport interface GetCellTypeOptions {\n  node: Node;\n  row: number;\n  col: number;\n}\n\n/**\n * Split a selected cell, whose rowpan or colspan is greater than one,\n * into smaller cells with the cell type (th, td) returned by getType function.\n *\n * @public\n */\nexport function splitCellWithType(\n  getCellType: (options: GetCellTypeOptions) => NodeType,\n): Command {\n  return (state, dispatch) => {\n    const sel = state.selection;\n    let cellNode: Node | null | undefined;\n    let cellPos: number | undefined;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = cellAround(sel.$from)?.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state),\n        tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth\n            ? {\n                ...baseAttrs,\n                colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null,\n              }\n            : baseAttrs,\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            (lastCell = tr.mapping.map(pos + rect.tableStart, 1)),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])!,\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0],\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : undefined,\n          ),\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Returns a command that sets the given attribute to the given value,\n * and is only available when the currently selected cell doesn't\n * already have that attribute set to that value.\n *\n * @public\n */\nexport function setCellAttr(name: string, value: unknown): Command {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter!.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value,\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter!.attrs,\n          [name]: value,\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\nfunction deprecated_toggleHeader(type: ToggleHeaderType): Command {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == 'column'\n          ? {\n              left: rect.left,\n              top: 0,\n              right: rect.right,\n              bottom: rect.map.height,\n            }\n          : type == 'row'\n            ? {\n                left: 0,\n                top: rect.top,\n                right: rect.map.width,\n                bottom: rect.bottom,\n              }\n            : rect,\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos)!);\n      for (\n        let i = 0;\n        i < cells.length;\n        i++ // Remove headers, if any\n      )\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs,\n          );\n      if (tr.steps.length === 0)\n        for (\n          let i = 0;\n          i < cells.length;\n          i++ // No headers removed, add instead\n        )\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs,\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\nfunction isHeaderEnabledByType(\n  type: 'row' | 'column',\n  rect: TableRect,\n  types: Record<string, NodeType>,\n): boolean {\n  // Get cell positions for first row or first column\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == 'row' ? rect.map.width : 1,\n    bottom: type == 'column' ? rect.map.height : 1,\n  });\n\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @public\n */\nexport type ToggleHeaderType = 'column' | 'row' | 'cell';\n\n/**\n * Toggles between row/column header and normal cells (Only applies to first row/column).\n * For deprecated behavior pass `useDeprecatedLogic` in options with true.\n *\n * @public\n */\nexport function toggleHeader(\n  type: ToggleHeaderType,\n  options?: { useDeprecatedLogic: boolean },\n): Command {\n  options = options || { useDeprecatedLogic: false };\n\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n\n      const isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        'column',\n        rect,\n        types,\n      );\n\n      const isHeaderEnabled =\n        type === 'column'\n          ? isHeaderRowEnabled\n          : type === 'row'\n            ? isHeaderColumnEnabled\n            : false;\n\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n\n      const cellsRect =\n        type == 'column'\n          ? {\n              left: 0,\n              top: selectionStartsAt,\n              right: 1,\n              bottom: rect.map.height,\n            }\n          : type == 'row'\n            ? {\n                left: selectionStartsAt,\n                top: 0,\n                right: rect.map.width,\n                bottom: 1,\n              }\n            : rect;\n\n      const newType =\n        type == 'column'\n          ? isHeaderColumnEnabled\n            ? types.cell\n            : types.header_cell\n          : type == 'row'\n            ? isHeaderRowEnabled\n              ? types.cell\n              : types.header_cell\n            : types.cell;\n\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Toggles whether the selected row contains header cells.\n *\n * @public\n */\nexport const toggleHeaderRow: Command = toggleHeader('row', {\n  useDeprecatedLogic: true,\n});\n\n/**\n * Toggles whether the selected column contains header cells.\n *\n * @public\n */\nexport const toggleHeaderColumn: Command = toggleHeader('column', {\n  useDeprecatedLogic: true,\n});\n\n/**\n * Toggles whether the selected cells are header cells.\n *\n * @public\n */\nexport const toggleHeaderCell: Command = toggleHeader('cell', {\n  useDeprecatedLogic: true,\n});\n\nfunction findNextCell($cell: ResolvedPos, dir: Direction): number | null {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (\n      let row = $cell.index(-1) - 1, rowEnd = $cell.before();\n      row >= 0;\n      row--\n    ) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter!.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (\n      let row = $cell.indexAfter(-1), rowStart = $cell.after();\n      row < table.childCount;\n      row++\n    ) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\n\n/**\n * Returns a command for selecting the next (direction=1) or previous\n * (direction=-1) cell in a table.\n *\n * @public\n */\nexport function goToNextCell(direction: Direction): Command {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr\n          .setSelection(TextSelection.between($cell, moveCellForward($cell)))\n          .scrollIntoView(),\n      );\n    }\n    return true;\n  };\n}\n\n/**\n * Deletes the table around the selection, if any.\n *\n * @public\n */\nexport function deleteTable(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == 'table') {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView(),\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Deletes the content of the selected cells, if they are not empty.\n *\n * @public\n */\nexport function deleteCellSelection(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill()!\n      .content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice(baseContent, 0, 0),\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\n/**\n * Options for moveTableRow\n *\n * @public\n */\nexport interface MoveTableRowOptions {\n  /**\n   * The source row index to move from.\n   */\n  from: number;\n\n  /**\n   * The destination row index to move to.\n   */\n  to: number;\n\n  /**\n   * Whether to select the moved row after the operation.\n   *\n   * @default true\n   */\n  select?: boolean;\n\n  /**\n   * Optional position to resolve table from. If not provided, uses the current selection.\n   */\n  pos?: number;\n}\n\n/**\n * Move a table row from index `from` to index `to`.\n *\n * @public\n */\nexport function moveTableRow(options: MoveTableRowOptions): Command {\n  return (state, dispatch) => {\n    const {\n      from: originIndex,\n      to: targetIndex,\n      select = true,\n      pos = state.selection.from,\n    } = options;\n    const tr = state.tr;\n    if (moveRow({ tr, originIndex, targetIndex, select, pos })) {\n      dispatch?.(tr);\n      return true;\n    }\n    return false;\n  };\n}\n\n/**\n * Options for moveTableColumn\n *\n * @public\n */\nexport interface MoveTableColumnOptions {\n  /**\n   * The source column index to move from.\n   */\n  from: number;\n\n  /**\n   * The destination column index to move to.\n   */\n  to: number;\n\n  /**\n   * Whether to select the moved column after the operation.\n   *\n   * @default true\n   */\n  select?: boolean;\n\n  /**\n   * Optional position to resolve table from. If not provided, uses the current selection.\n   */\n  pos?: number;\n}\n\n/**\n * Move a table column from index `from` to index `to`.\n *\n * @public\n */\nexport function moveTableColumn(options: MoveTableColumnOptions): Command {\n  return (state, dispatch) => {\n    const {\n      from: originIndex,\n      to: targetIndex,\n      select = true,\n      pos = state.selection.from,\n    } = options;\n    const tr = state.tr;\n    if (moveColumn({ tr, originIndex, targetIndex, select, pos })) {\n      dispatch?.(tr);\n      return true;\n    }\n    return false;\n  };\n}\n","// Utilities used for copy/paste handling.\n//\n// This module handles pasting cell content into tables, or pasting\n// anything into a cell selection, as replacing a block of cells with\n// the content of the selection. When pasting cells into a cell, that\n// involves placing the block of pasted content so that its top left\n// aligns with the selection cell, optionally extending the table to\n// the right or bottom to make sure it is large enough. Pasting into a\n// cell selection is different, here the cells in the selection are\n// clipped to the selection's rectangle, optionally repeating the\n// pasted cells when they are smaller than the selection.\n\nimport type { Node, NodeType, Schema } from 'prosemirror-model';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport type { EditorState, Transaction } from 'prosemirror-state';\nimport { Transform } from 'prosemirror-transform';\n\nimport { CellSelection } from './cellselection';\nimport { tableNodeTypes } from './schema';\nimport type { ColWidths, Rect } from './tablemap';\nimport { TableMap } from './tablemap';\nimport type { CellAttrs } from './util';\nimport { removeColSpan } from './util';\n\n/**\n * @internal\n */\nexport type Area = { width: number; height: number; rows: Fragment[] };\n\n// Utilities to help with copying and pasting table cells\n\n/**\n * Get a rectangular area of cells from a slice, or null if the outer\n * nodes of the slice aren't table cells or rows.\n *\n * @internal\n */\nexport function pastedCells(slice: Slice): Area | null {\n  if (slice.size === 0) return null;\n  let { content, openStart, openEnd } = slice;\n  while (\n    content.childCount == 1 &&\n    ((openStart > 0 && openEnd > 0) ||\n      content.child(0).type.spec.tableRole == 'table')\n  ) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema,\n    rows = [];\n  if (role == 'row') {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice(cells, left, right),\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == 'cell' || role == 'header_cell') {\n    rows.push(\n      openStart || openEnd\n        ? fitSlice(\n            tableNodeTypes(schema).row,\n            new Slice(content, openStart, openEnd),\n          ).content\n        : content,\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\n\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nfunction ensureRectangular(schema: Schema, rows: Fragment[]): Area {\n  const widths: ColWidths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill()!;\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\n\nexport function fitSlice(nodeType: NodeType, slice: Slice): Node {\n  const node = nodeType.createAndFill()!;\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\n\n/**\n * Clip or extend (repeat) the given set of cells to cover the given\n * width and height. Will clip rowspan/colspan cells at the edges when\n * they stick out.\n *\n * @internal\n */\nexport function clipCells(\n  { width, height, rows }: Area,\n  newWidth: number,\n  newHeight: number,\n): Area {\n  if (width != newWidth) {\n    const added: number[] = [];\n    const newRows: Fragment[] = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row],\n        cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs as CellAttrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth,\n            ),\n            cell.content,\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [],\n        source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan),\n            },\n            cell.content,\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n\n  return { width, height, rows };\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(\n  tr: Transaction,\n  map: TableMap,\n  table: Node,\n  start: number,\n  width: number,\n  height: number,\n  mapFrom: number,\n): boolean {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells: Node[] = [];\n      let add: Node;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill()!);\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill()!);\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (\n      let i = 0, start = (map.height - 1) * map.width;\n      i < Math.max(map.width, width);\n      i++\n    ) {\n      const header =\n        i >= map.width\n          ? false\n          : table.nodeAt(map.map[start + i])!.type == types.header_cell;\n      cells.push(\n        header\n          ? emptyHead || (emptyHead = types.header_cell.createAndFill()!)\n          : empty || (empty = types.cell.createAndFill()!),\n      );\n    }\n\n    const emptyRow = types.row.create(null, Fragment.from(cells)),\n      rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(\n  tr: Transaction,\n  map: TableMap,\n  table: Node,\n  start: number,\n  left: number,\n  right: number,\n  top: number,\n  mapFrom: number,\n): boolean {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col,\n      pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos)!;\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop,\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top,\n        })!,\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(\n  tr: Transaction,\n  map: TableMap,\n  table: Node,\n  start: number,\n  top: number,\n  bottom: number,\n  left: number,\n  mapFrom: number,\n): boolean {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left,\n      pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos)!;\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs as CellAttrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft),\n        ),\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs as CellAttrs, 0, left - cellLeft),\n        )!,\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\n\n/**\n * Insert the given set of cells (as returned by `pastedCells`) into a\n * table, at the position pointed at by rect.\n *\n * @internal\n */\nexport function insertCells(\n  state: EditorState,\n  dispatch: (tr: Transaction) => void,\n  tableStart: number,\n  rect: Rect,\n  cells: Area,\n): void {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error('No table found');\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width,\n    bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n\n  function recomp(): void {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error('No table found');\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n\n  // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (\n    isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)\n  )\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table),\n      to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice(cells.rows[row - top], 0, 0),\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table)),\n    ),\n  );\n  dispatch(tr);\n}\n","// This file defines a number of helpers for wiring up user input to\n// table-related functionality.\n\nimport { keydownHandler } from 'prosemirror-keymap';\nimport type { ResolvedPos, Slice } from 'prosemirror-model';\nimport { Fragment } from 'prosemirror-model';\nimport type { Command, EditorState, Transaction } from 'prosemirror-state';\nimport { Selection, TextSelection } from 'prosemirror-state';\nimport type { EditorView } from 'prosemirror-view';\n\nimport { CellSelection } from './cellselection';\nimport { deleteCellSelection } from './commands';\nimport { clipCells, fitSlice, insertCells, pastedCells } from './copypaste';\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './tablemap';\nimport {\n  cellAround,\n  inSameTable,\n  isInTable,\n  nextCell,\n  selectionCell,\n  tableEditingKey,\n} from './util';\n\ntype Axis = 'horiz' | 'vert';\n\n/**\n * @public\n */\nexport type Direction = -1 | 1;\n\nexport const handleKeyDown = keydownHandler({\n  ArrowLeft: arrow('horiz', -1),\n  ArrowRight: arrow('horiz', 1),\n  ArrowUp: arrow('vert', -1),\n  ArrowDown: arrow('vert', 1),\n\n  'Shift-ArrowLeft': shiftArrow('horiz', -1),\n  'Shift-ArrowRight': shiftArrow('horiz', 1),\n  'Shift-ArrowUp': shiftArrow('vert', -1),\n  'Shift-ArrowDown': shiftArrow('vert', 1),\n\n  Backspace: deleteCellSelection,\n  'Mod-Backspace': deleteCellSelection,\n  Delete: deleteCellSelection,\n  'Mod-Delete': deleteCellSelection,\n});\n\nfunction maybeSetSelection(\n  state: EditorState,\n  dispatch: undefined | ((tr: Transaction) => void),\n  selection: Selection,\n): boolean {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\n\n/**\n * @internal\n */\nexport function arrow(axis: Axis, dir: Direction): Command {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection.near(sel.$headCell, dir),\n      );\n    }\n    if (axis != 'horiz' && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == 'horiz') {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection.near(state.doc.resolve(sel.head + dir), dir),\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = Selection.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\n\nfunction shiftArrow(axis: Axis, dir: Direction): Command {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel: CellSelection;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head),\n    );\n  };\n}\n\nexport function handleTripleClick(view: EditorView, pos: number): boolean {\n  const doc = view.state.doc,\n    $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\n\n/**\n * @public\n */\nexport function handlePaste(\n  view: EditorView,\n  _: ClipboardEvent,\n  slice: Slice,\n): boolean {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice),\n          ),\n        ],\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start,\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells,\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function handleMouseDown(\n  view: EditorView,\n  startEvent: MouseEvent,\n): void {\n  // Only handle mouse down events for the main button (usually the left button).\n  // This ensures that the cell selection won't be triggered when trying to open\n  // the context menu.\n  if (startEvent.button != 0) return;\n\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n\n  const startDOMCell = domInCell(view, startEvent.target as Node);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (\n    startEvent.shiftKey &&\n    startDOMCell &&\n    ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n    cellUnderMouse(view, startEvent)?.pos != $anchor.pos\n  ) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return;\n  }\n\n  // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n  function setCellSelection($anchor: ResolvedPos, event: MouseEvent): void {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) $head = $anchor;\n      else return;\n    }\n    const selection = new CellSelection($anchor, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor.pos);\n      view.dispatch(tr);\n    }\n  }\n\n  // Stop listening to mouse motion events.\n  function stop(): void {\n    view.root.removeEventListener('mouseup', stop);\n    view.root.removeEventListener('dragstart', stop);\n    view.root.removeEventListener('mousemove', move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n\n  function move(_event: Event): void {\n    const event = _event as MouseEvent;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor;\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target as Node) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n      if (!$anchor) return stop();\n    }\n    if ($anchor) setCellSelection($anchor, event);\n  }\n\n  view.root.addEventListener('mouseup', stop);\n  view.root.addEventListener('dragstart', stop);\n  view.root.addEventListener('mousemove', move);\n}\n\n// Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\nfunction atEndOfCell(view: EditorView, axis: Axis, dir: number): null | number {\n  if (!(view.state.selection instanceof TextSelection)) return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d),\n      index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (\n      parent.type.spec.tableRole == 'cell' ||\n      parent.type.spec.tableRole == 'header_cell'\n    ) {\n      const cellPos = $head.before(d);\n      const dirStr: 'up' | 'down' | 'left' | 'right' =\n        axis == 'vert' ? (dir > 0 ? 'down' : 'up') : dir > 0 ? 'right' : 'left';\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\n\nfunction domInCell(view: EditorView, dom: Node | null): Node | null {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == 'TD' || dom.nodeName == 'TH') {\n      return dom;\n    }\n  }\n  return null;\n}\n\nfunction cellUnderMouse(\n  view: EditorView,\n  event: MouseEvent,\n): ResolvedPos | null {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY,\n  });\n  if (!mousePos) return null;\n  // Prefer `inside` position for better accuracy with merged cells (rowspan/colspan),\n  // but fall back to `pos` if `inside` doesn't resolve to a valid cell\n  let { inside, pos } = mousePos;\n  return (\n    (inside >= 0 && cellAround(view.state.doc.resolve(inside))) ||\n    cellAround(view.state.doc.resolve(pos))\n  );\n}\n","import type { Node } from 'prosemirror-model';\nimport type { NodeView, ViewMutationRecord } from 'prosemirror-view';\n\nimport type { CellAttrs } from './util';\n\n/**\n * @public\n */\nexport class TableView implements NodeView {\n  public dom: HTMLDivElement;\n  public table: HTMLTableElement;\n  public colgroup: HTMLTableColElement;\n  public contentDOM: HTMLTableSectionElement;\n\n  constructor(\n    public node: Node,\n    public defaultCellMinWidth: number,\n  ) {\n    this.dom = document.createElement('div');\n    this.dom.className = 'tableWrapper';\n    this.table = this.dom.appendChild(document.createElement('table'));\n    this.table.style.setProperty(\n      '--default-cell-min-width',\n      `${defaultCellMinWidth}px`,\n    );\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n  }\n\n  update(node: Node): boolean {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(\n      node,\n      this.colgroup,\n      this.table,\n      this.defaultCellMinWidth,\n    );\n    return true;\n  }\n\n  ignoreMutation(record: ViewMutationRecord): boolean {\n    return (\n      record.type == 'attributes' &&\n      (record.target == this.table || this.colgroup.contains(record.target))\n    );\n  }\n}\n\n/**\n * @public\n */\nexport function updateColumnsOnResize(\n  node: Node,\n  colgroup: HTMLTableColElement,\n  table: HTMLTableElement,\n  defaultCellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n): void {\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild as HTMLElement;\n  const row = node.firstChild;\n  if (!row) return;\n\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs as CellAttrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth =\n        overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + 'px' : '';\n      totalWidth += hasWidth || defaultCellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        const col = document.createElement('col');\n        col.style.width = cssWidth;\n        colgroup.appendChild(col);\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling as HTMLElement;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    nextDOM.parentNode?.removeChild(nextDOM);\n    nextDOM = after as HTMLElement;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + 'px';\n    table.style.minWidth = '';\n  } else {\n    table.style.width = '';\n    table.style.minWidth = totalWidth + 'px';\n  }\n}\n","import type { Attrs, Node as ProsemirrorNode } from 'prosemirror-model';\nimport type { EditorState, Transaction } from 'prosemirror-state';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport type { EditorView, NodeView } from 'prosemirror-view';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\n\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './tablemap';\nimport { TableView, updateColumnsOnResize } from './tableview';\nimport type { CellAttrs } from './util';\nimport { cellAround, pointsAtCell } from './util';\n\n/**\n * @public\n */\nexport const columnResizingPluginKey = new PluginKey<ResizeState>(\n  'tableColumnResizing',\n);\n\n/**\n * @public\n */\nexport type ColumnResizingOptions = {\n  handleWidth?: number;\n  /**\n   * Minimum width of a cell /column. The column cannot be resized smaller than this.\n   */\n  cellMinWidth?: number;\n  /**\n   * The default minWidth of a cell / column when it doesn't have an explicit width (i.e.: it has not been resized manually)\n   */\n  defaultCellMinWidth?: number;\n  lastColumnResizable?: boolean;\n  /**\n   * A custom node view for the rendering table nodes. By default, the plugin\n   * uses the {@link TableView} class. You can explicitly set this to `null` to\n   * not use a custom node view.\n   */\n  View?:\n    | (new (\n        node: ProsemirrorNode,\n        cellMinWidth: number,\n        view: EditorView,\n      ) => NodeView)\n    | null;\n};\n\n/**\n * @public\n */\nexport type Dragging = { startX: number; startWidth: number };\n\n/**\n * @public\n */\nexport function columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  defaultCellMinWidth = 100,\n  View = TableView,\n  lastColumnResizable = true,\n}: ColumnResizingOptions = {}): Plugin {\n  const plugin = new Plugin<ResizeState>({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        const nodeViews = plugin.spec?.props?.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, defaultCellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      },\n    },\n    props: {\n      attributes: (state): Record<string, string> => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1\n          ? { class: 'resize-cursor' }\n          : {};\n      },\n\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown(view, event, cellMinWidth, defaultCellMinWidth);\n        },\n      },\n\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n\n      nodeViews: {},\n    },\n  });\n  return plugin;\n}\n\n/**\n * @public\n */\nexport class ResizeState {\n  constructor(\n    public activeHandle: number,\n    public dragging: Dragging | false,\n  ) {}\n\n  apply(tr: Transaction): ResizeState {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== undefined)\n      return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n}\n\nfunction handleMouseMove(\n  view: EditorView,\n  event: MouseEvent,\n  handleWidth: number,\n  lastColumnResizable: boolean,\n): void {\n  if (!view.editable) return;\n\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target as HTMLElement);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, 'left', handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, 'right', handleWidth);\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col =\n          map.colCount($cell.pos - tableStart) +\n          $cell.nodeAfter!.attrs.colspan -\n          1;\n\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view: EditorView): void {\n  if (!view.editable) return;\n\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\n\nfunction handleMouseDown(\n  view: EditorView,\n  event: MouseEvent,\n  cellMinWidth: number,\n  defaultCellMinWidth: number,\n): boolean {\n  if (!view.editable) return false;\n\n  const win = view.dom.ownerDocument.defaultView ?? window;\n\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle)!;\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width },\n    }),\n  );\n\n  function finish(event: MouseEvent) {\n    win.removeEventListener('mouseup', finish);\n    win.removeEventListener('mousemove', move);\n    const pluginState = columnResizingPluginKey.getState(view.state);\n    if (pluginState?.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState.activeHandle,\n        draggedWidth(pluginState.dragging, event, cellMinWidth),\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null }),\n      );\n    }\n  }\n\n  function move(event: MouseEvent): void {\n    if (!event.which) return finish(event);\n    const pluginState = columnResizingPluginKey.getState(view.state);\n    if (!pluginState) return;\n    if (pluginState.dragging) {\n      const dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n      displayColumnWidth(\n        view,\n        pluginState.activeHandle,\n        dragged,\n        defaultCellMinWidth,\n      );\n    }\n  }\n\n  displayColumnWidth(\n    view,\n    pluginState.activeHandle,\n    width,\n    defaultCellMinWidth,\n  );\n\n  win.addEventListener('mouseup', finish);\n  win.addEventListener('mousemove', move);\n  event.preventDefault();\n  return true;\n}\n\nfunction currentColWidth(\n  view: EditorView,\n  cellPos: number,\n  { colspan, colwidth }: Attrs,\n): number {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset] as HTMLElement;\n  let domWidth = node.offsetWidth,\n    parts = colspan;\n  if (colwidth)\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  return domWidth / parts;\n}\n\nfunction domCellAround(target: HTMLElement | null): HTMLElement | null {\n  while (target && target.nodeName != 'TD' && target.nodeName != 'TH')\n    target =\n      target.classList && target.classList.contains('ProseMirror')\n        ? null\n        : (target.parentNode as HTMLElement);\n  return target;\n}\n\nfunction edgeCell(\n  view: EditorView,\n  event: MouseEvent,\n  side: 'left' | 'right',\n  handleWidth: number,\n): number {\n  // posAtCoords returns inconsistent positions when cursor is moving\n  // across a collapsed table border. Use an offset to adjust the\n  // target viewport coordinates away from the table border.\n  const offset = side == 'right' ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY,\n  });\n  if (!found) return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == 'right') return $cell.pos;\n  const map = TableMap.get($cell.node(-1)),\n    start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\n\nfunction draggedWidth(\n  dragging: Dragging,\n  event: MouseEvent,\n  resizeMinWidth: number,\n): number {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\n\nfunction updateHandle(view: EditorView, value: number): void {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value }),\n  );\n}\n\nfunction updateColumnWidth(\n  view: EditorView,\n  cell: number,\n  width: number,\n): void {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    map = TableMap.get(table),\n    start = $cell.start(-1);\n  const col =\n    map.colCount($cell.pos - start) + $cell.nodeAfter!.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    // Rowspanning cell that has already been handled\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos)!.attrs as CellAttrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth\n      ? attrs.colwidth.slice()\n      : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth: colwidth });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\n\nfunction displayColumnWidth(\n  view: EditorView,\n  cell: number,\n  width: number,\n  defaultCellMinWidth: number,\n): void {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    start = $cell.start(-1);\n  const col =\n    TableMap.get(table).colCount($cell.pos - start) +\n    $cell.nodeAfter!.attrs.colspan -\n    1;\n  let dom: Node | null = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != 'TABLE') {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild as HTMLTableColElement,\n    dom as HTMLTableElement,\n    defaultCellMinWidth,\n    col,\n    width,\n  );\n}\n\nfunction zeroes(n: number): 0[] {\n  return Array(n).fill(0);\n}\n\nexport function handleDecorations(\n  state: EditorState,\n  cell: number,\n): DecorationSet {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col =\n    map.colCount($cell.pos - start) + $cell.nodeAfter!.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    // For positions that have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n    if (\n      (col == map.width - 1 || map.map[index] != map.map[index + 1]) &&\n      (row == 0 || map.map[index] != map.map[index - map.width])\n    ) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos)!.nodeSize - 1;\n      const dom = document.createElement('div');\n      dom.className = 'column-resize-handle';\n      if (columnResizingPluginKey.getState(state)?.dragging) {\n        decorations.push(\n          Decoration.node(\n            start + cellPos,\n            start + cellPos + table.nodeAt(cellPos)!.nodeSize,\n            {\n              class: 'column-resize-dragging',\n            },\n          ),\n        );\n      }\n\n      decorations.push(Decoration.widget(pos, dom));\n    }\n  }\n  return DecorationSet.create(state.doc, decorations);\n}\n","// This file defines a plugin that handles the drawing of cell\n// selections and the basic user interactions for creating and working\n// with such selections. It also makes sure that, after each\n// transaction, the shapes of tables are normalized to be rectangular\n// and not contain overlapping cells.\n\nimport { Plugin } from 'prosemirror-state';\n\nimport { drawCellSelection, normalizeSelection } from './cellselection';\nimport { fixTables, fixTablesKey } from './fixtables';\nimport {\n  handleKeyDown,\n  handleMouseDown,\n  handlePaste,\n  handleTripleClick,\n} from './input';\nimport { tableEditingKey } from './util';\n\nexport { CellBookmark, CellSelection } from './cellselection';\nexport type { CellSelectionJSON } from './cellselection';\nexport {\n  columnResizing,\n  columnResizingPluginKey,\n  ResizeState,\n} from './columnresizing';\nexport type { ColumnResizingOptions, Dragging } from './columnresizing';\nexport * from './commands';\nexport {\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n} from './copypaste';\nexport type { Area as __Area } from './copypaste';\nexport type { Direction } from './input';\nexport { tableNodes, tableNodeTypes } from './schema';\nexport type {\n  CellAttributes,\n  getFromDOM,\n  setDOMAttr,\n  TableNodes,\n  TableNodesOptions,\n  TableRole,\n} from './schema';\nexport { TableMap } from './tablemap';\nexport type { ColWidths, Problem, Rect } from './tablemap';\nexport { TableView, updateColumnsOnResize } from './tableview';\nexport {\n  addColSpan,\n  cellAround,\n  cellNear,\n  colCount,\n  columnIsHeader,\n  findCell,\n  inSameTable,\n  isInTable,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  selectionCell,\n} from './util';\nexport type { MutableAttrs } from './util';\nexport { findCellPos, findCellRange, findTable } from './utils/query';\nexport type { FindNodeResult } from './utils/query';\nexport { fixTables, fixTablesKey, handlePaste, tableEditingKey };\n\n/**\n * @public\n */\nexport type TableEditingOptions = {\n  /**\n   * Whether to allow table node selection.\n   *\n   * By default, any node selection wrapping a table will be converted into a\n   * CellSelection wrapping all cells in the table. You can pass `true` to allow\n   * the selection to remain a NodeSelection.\n   *\n   * @default false\n   */\n  allowTableNodeSelection?: boolean;\n};\n\n/**\n * Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n * that, when added to an editor, enables cell-selection, handles\n * cell-based copy/paste, and makes sure tables stay well-formed (each\n * row has the same width, and cells don't overlap).\n *\n * You should probably put this plugin near the end of your array of\n * plugins, since it handles mouse and arrow key events in tables\n * rather broadly, and other plugins, like the gap cursor or the\n * column-width dragging plugin, might want to get a turn first to\n * perform more specific behavior.\n *\n * @public\n */\nexport function tableEditing({\n  allowTableNodeSelection = false,\n}: TableEditingOptions = {}): Plugin {\n  return new Plugin({\n    key: tableEditingKey,\n\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      },\n    },\n\n    props: {\n      decorations: drawCellSelection,\n\n      handleDOMEvents: {\n        mousedown: handleMouseDown,\n      },\n\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null\n          ? view.state.selection\n          : null;\n      },\n\n      handleTripleClick,\n\n      handleKeyDown,\n\n      handlePaste,\n    },\n\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection,\n      );\n    },\n  });\n}\n"],"mappings":"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"}